%!PS-Adobe-2.0 EPSF-1.2
%%Creator: ARC/INFO Version 7.1.1
%%CreationDate: 6/02/1998 9:40 AM
%%DocumentProcSets: ARC/INFO_7.1.1_encapsulate 0 0
%%+ ARC/INFO_7.1.1_illustrator_emulate 0 0
%%+ ARC/INFO_7.1.1_film_marks 0 0
%%+ ARC/INFO_7.1.1_image 0 0
%%+ ARC/INFO_7.1.1_separate 0 0
%%DocumentSuppliedProcSets: ARC/INFO_7.1.1_encapsulate 0 0
%%+ ARC/INFO_7.1.1_illustrator_emulate 0 0
%%+ ARC/INFO_7.1.1_film_marks 0 0
%%+ ARC/INFO_7.1.1_image 0 0
%%+ ARC/INFO_7.1.1_separate 0 0
%%ColorUsage: Color
%%BoundingBox: 192 7 292 147                
%%TemplateBox: 192 7 292 147                
%%EndComments
%%BeginProlog
%%BeginProcSet: ARC/INFO_7.1.1_encapsulate 0 0

%
%  Utility functions
%
clippath pathbbox pop pop translate newpath %% [PJH] make origin origin of imaga

/bdf { bind def } def

%
%  Encapsulation functions
%

/BEGINEPSFILE { /EPSFsave save def
                0 setgray 0 setlinecap
                1 setlinewidth 0 setlinejoin
                10 setmiterlimit [] 0 setdash newpath
                /showpage {} def
              } bdf
/ENDEPSFILE   { EPSFsave restore } bdf

%%EndProcSet
%%BeginProcSet: ARC/INFO_7.1.1_illustrator_emulate 0 0

%
%  Utility functions
%

/bdf      { bind def } def
/.strok   { .w setlinewidth .M setmiterlimit
            .J setlinecap .j setlinejoin stroke } bdf
/mkz      { 4 {
                dup 0 lt { pop 0 } if 4 1 roll
              } repeat
          } bdf
/vk2v     { _KK sub dup 0 lt
            { pop 0 } if
            _KK add 3 1 roll
          } bdf
/cmyk2cmy { /_KK exch def
            3 { vk2v } repeat
          } bdf
/dc       { exch 1 exch sub def } bdf
/dc_      { exch def } bdf
/krnprc   { pop pop krnary krncnt get lastx add 0 moveto
            /lastx currentpoint pop def
            /krncnt krncnt 1 add def } bdf

%
%  ISOLatin1 font encoding utilities
%

/validISOLatin1 { /ISOLatin1Encoding where { pop } {
   /ISOLatin1Encoding[/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
   /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
   /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
   /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/space/exclam
   /quotedbl/numbersign/dollar/percent/ampersand/quoteright/parenleft
   /parenright/asterisk/plus/comma/minus/period/slash/zero/one/two/three/four
   /five/six/seven/eight/nine/colon/semicolon/less/equal/greater/question/at
   /A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash
   /bracketright/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m/n
   /o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef/.notdef
   /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
   /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/dotlessi/grave/acute
   /circumflex/tilde/macron/breve/dotaccent/dieresis/.notdef/ring/cedilla
   /.notdef/hungarumlaut/ogonek/caron/space/exclamdown/cent/sterling/currency
   /yen/brokenbar/section/dieresis/copyright/ordfeminine/guillemotleft
   /logicalnot/hyphen/registered/macron/degree/plusminus/twosuperior
   /threesuperior/acute/mu/paragraph/periodcentered/cedilla/onesuperior
   /ordmasculine/guillemotright/onequarter/onehalf/threequarters/questiondown
   /Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla/Egrave/Eacute
   /Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis/Eth/Ntilde/Ograve
   /Oacute/Ocircumflex/Otilde/Odieresis/multiply/Oslash/Ugrave/Uacute
   /Ucircumflex/Udieresis/Yacute/Thorn/germandbls/agrave/aacute/acircumflex
   /atilde/adieresis/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis
   /igrave/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
   /otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis/yacute
   /thorn/ydieresis]def } ifelse } bdf
/setISOLatin1font {
   validISOLatin1 dup findfont dup /ISOLatin1 known
   1 index /FontType get 3 eq or { exch pop }
   { dup maxlength 1 add dict dup /DICT_ exch def begin
   { 1 index /FID eq { pop pop } { def } ifelse } forall
   /Encoding ISOLatin1Encoding def /ISOLatin1 1 def end
   DICT_ definefont } ifelse } bdf

%
%  Illustrator recognized functions
%

/k { mkz /setcmykcolor where
     { pop /_k dc_ /_y dc_ /_m dc_ /_c dc_
       /sc { _c _m _y _k setcmykcolor } def }
     { cmyk2cmy 2 copy eq 3 index 3 index eq and
       { pop pop /_k dc /sc { _k setgray } def }
       { /_b dc /_g dc /_r dc /sc { _r _g _b setrgbcolor } def } ifelse
     } ifelse
     /F { sc eofill } def /im { sc _im } def _opon
   } bdf
/K { mkz /setcmykcolor where
     { pop /_K dc_ /_Y dc_ /_M dc_ /_C dc_
       /SC { _C _M _Y _K setcmykcolor } def }
     { cmyk2cmy 2 copy eq 3 index 3 index eq and
       { pop pop /_K dc /SC { _K setgray } def }
       { /_B dc /_G dc /_R dc /SC { _R _G _B setrgbcolor } def } ifelse
     } ifelse
     /S { SC .strok } def /IM { SC _im } def
   } bdf
/x { dup -1 eq { pop } if pop pop /setcmykcolor where
     { pop /_k dc_ /_y dc_ /_m dc_ /_c dc_
       /sc { _c _m _y _k setcmykcolor } def }
     { cmyk2cmy 2 copy eq 3 index 3 index eq and
       { pop pop /_k dc /sc { _k setgray } def }
       { /_b dc /_g dc /_r dc /sc { _r _g _b setrgbcolor } def } ifelse
     } ifelse
     /F { sc eofill } def /im { sc _im } def _opon
   } bdf
/X { dup -1 eq { pop } if pop pop /setcmykcolor where
     { pop /_K dc_ /_Y dc_ /_M dc_ /_C dc_
       /SC { _C _M _Y _K setcmykcolor } def }
     { cmyk2cmy 2 copy eq 3 index 3 index eq and
       { pop pop /_K dc /SC { _K setgray } def }
       { /_B dc /_G dc /_R dc /SC { _R _G _B setrgbcolor } def } ifelse
     } ifelse
     /S { SC .strok } def /IM { SC _im } def
   } bdf
/B { gsave F grestore } bdf
/l { lineto } bdf
/m { moveto } bdf
/c { curveto } bdf
/w { /.w exch def } bdf
/M { /.M exch def } bdf
/J { /.J exch def } bdf
/j { /.j exch def } bdf
/u {} bdf
/U {} bdf
/z { grestore
     5 -1 roll setISOLatin1font
     5 -1 roll scalefont setfont pop
     /_kern exch def pop
     gsave
   } bdf
/e { gsave concat } bdf
/t { sc 0 0 moveto /krnary where
     { pop /krncnt 0 def /lastx 0 def { krnprc } exch kshow pop }
     { _kern exch 0 exch ashow pop } ifelse } bdf
/T { grestore } bdf
/F4 { m l l l F } bdf
/F3 { m l l F } bdf

%
%  Tile eofill functions
%

/_opon { /_op true def } bdf
/_opof { /_op false def } bdf
/trTb { _opof } bdf

/_im { imagemask } bdf
/eatim { 5{pop}repeat } bdf

/TL { [ 3 index 0 0 5 index neg 0 7 index ] exch
   _op { 4 copy 4 2 roll false 5 -2 roll im } if
   4 2 roll true 5 -2 roll IM } bdf

/TF { gsave clip pathbbox newpath
   4 -2 roll exch 5 index div cvi 5 index mul exch 4 index div cvi 4 index mul
   2 copy translate 3 -1 roll exch sub 3 1 roll sub 3 index div cvi 1 add
   exch 2 index div cvi 1 add 4 2 roll scale
   {  gsave dup
      {  1 index cvx exec
         1 0 translate
      } repeat
      grestore 0 1 translate
   } repeat
   grestore newpath pop pop
} bdf

%%EndProcSet
%%BeginProcSet: ARC/INFO_7.1.1_film_marks 0 0

%
%  Utility functions
%

/bdf { bind def } def

%
%  Film mark functions
%

/regmrk    { gsave translate .1 setlinewidth
             0 setgray
             0 0 8 0 360 arc stroke
             0 0 4 0 360 arc eofill
             -10 0 moveto 10 0 lineto
             0 -10 moveto 0 10 lineto stroke
             1 setgray
             -4 0 moveto 4 0 lineto
             0 -4 moveto 0 4 lineto stroke grestore
           } bdf
/crpmrk_ll { gsave translate 0 setgray
             .72 setlinewidth
             0 18 moveto 0 0 lineto 18 0 lineto stroke
             .1 setlinewidth
             -24 0 moveto -4 0 lineto stroke
             0 -24 moveto 0 -4 lineto stroke grestore
           } bdf
/crpmrk_ul { gsave translate 0 setgray
             .72 setlinewidth
             0 -18 moveto 0 0 lineto 18 0 lineto stroke
             .1 setlinewidth
             -24 0 moveto -4 0 lineto stroke
             0 24 moveto 0 4 lineto stroke grestore
           } bdf
/crpmrk_ur { gsave translate 0 setgray
             .72 setlinewidth
             0 -18 moveto 0 0 lineto -18 0 lineto stroke
             .1 setlinewidth
             24 0 moveto 4 0 lineto stroke
             0 24 moveto 0 4 lineto stroke grestore
           } bdf
/crpmrk_lr { gsave translate 0 setgray
             .72 setlinewidth
             0 18 moveto 0 0 lineto -18 0 lineto stroke
             .1 setlinewidth
             24 0 moveto 4 0 lineto stroke
             0 -24 moveto 0 -4 lineto stroke grestore
           } bdf
/barmrk    { gsave translate
             /intense 1. def
             11 {
                  intense setgray
                  0 0 moveto 16 0 lineto 16 16 lineto
                  0 16 lineto 0 0 lineto eofill
                  0 16 translate
                  /intense intense .1 sub def
                } repeat
             grestore
           } bdf

%%EndProcSet
%%BeginProcSet: ARC/INFO_7.1.1_image 0 0

%
%  Utility functions
%

/bdf    { bind def } def
/in     { /cfnc 1   string def
          /val  ll  string def
          /buf1 381 string def
          /buf2 508 string def
        } bdf
/imgtrn { 6 -2 roll translate 4 -2 roll scale } bdf
/imgmtx { [ 3 index 0 0 5 index neg 0 0 ] } bdf
/as_set { /rdstr { readhexstring pop pop } def } bdf
/bn_set { /rdstr { readstring pop pop } def } bdf
/rdfunc { currentfile cfnc rdstr } bdf
/rd_buf { rdfunc cfnc 0 get dup 127 le
          { /ibf buf1 0 3 index ll mul getinterval def
            currentfile ibf rdstr pop }
          { 128 sub currentfile val rdstr
            /ibf buf1 0 3 index ll mul getinterval def /cnt 0 def
            { ibf cnt ll mul val putinterval /cnt cnt 1 add def } repeat }
          ifelse
        } bdf
/cl2bw  { /tbf ibf def /ibf buf2 0 ibf length 3 div cvi getinterval def
          /cnt 0 def ibf length
          { ibf cnt 3 div cvi
            3 { tbf cnt get /cnt cnt 1 add def } repeat
            .11 mul exch .59 mul add exch .3 mul add .1 add cvi put
          } repeat
        } bdf
/r2cimg { /tbf ibf def /ibf buf2 0 ibf length 3 div 4 mul cvi getinterval def
          /cnt 0 def tbf length 3 div cvi
          { 3 { tbf cnt get 255 exch sub /cnt cnt 1 add def } repeat
            2 copy eq 3 index 3 index eq and
            { pop pop 0 exch 0 exch 0 exch }
            { 0 } ifelse
            /cnt_ cnt 3 div 4 mul 1 sub cvi def
            4 { ibf exch cnt_ exch put /cnt_ cnt_ 1 sub def } repeat
          } repeat
        } bdf

%
%  Image functions
%

/imgmsk { /sc where { pop sc } if /ll 1 def in imgtrn true imgmtx
          { rd_buf ibf } imagemask
        } bdf
/gryimg { /ll 1 def in imgtrn 8 imgmtx { rd_buf ibf } image } bdf
/mnoimg { /ll 1 def in imgtrn 1 imgmtx { rd_buf ibf } image } bdf
/cl_img { /ll 3 def in imgtrn 8 imgmtx { rd_buf r2cimg ibf }
        false 4 colorimage } bdf
/bw_img { /ll 3 def in imgtrn 8 imgmtx { rd_buf cl2bw ibf } image } bdf

/imgmsk_a { as_set imgmsk } bdf
/gryimg_a { as_set gryimg } bdf
/mnoimg_a { as_set mnoimg } bdf
/clrimg_a { as_set /colorimage where { pop cl_img } { bw_img } ifelse } bdf
/imgmsk_b { bn_set imgmsk } bdf
/gryimg_b { bn_set gryimg } bdf
/mnoimg_b { bn_set mnoimg } bdf
/clrimg_b { bn_set /colorimage where { pop cl_img } { bw_img } ifelse } bdf

%%EndProcSet
%%BeginProcSet: ARC/INFO_7.1.1_separate 0 0

%
%  Utility functions
%

/bdf    { bind def } def
/txim   { /t { sc 0 0 moveto _kern exch 0 exch ashow pop } def
          /imgmsk_a { as_set imgmsk } def
          /imgmsk_b { bn_set imgmsk } def
        } bdf
/notxim { /t { pop pop } def
          /imgmsk_a { as_set imgmskeat } def
          /imgmsk_b { bn_set imgmskeat } def
        } bdf
/g      { /_b exch def
          /sc { _b setgray } def
          /F { sc eofill } def /im { sc _im } def _opon
        } bdf
/G      { /_B exch def
          /SC { _B setgray } def
          /S { SC .strok } def /IM { SC _im } def
        } bdf
/ksepr  { txim dup 0 lt
                { pop /F { newpath } def /im { eatim } def _opof notxim }
                { 1 exch sub /_b exch def /sc { _b setgray } def
                  /F { sc eofill } def /im { sc _im } def _opon }
                ifelse
        } bdf
/Ksepr  { dup 0 lt
                { pop /S { newpath } def /IM { eatim } def }
                { 1 exch sub /_B exch def /S { _B setgray .strok } def
                  /IM { _B setgray _im } def }
                ifelse
        } bdf
/cl2sep { /tbf ibf def /ibf buf2 0 ibf length 3 div cvi getinterval def
          /cnt 0 def ibf length
          { ibf cnt 3 div cvi
            3 { tbf cnt get  /cnt cnt 1 add def } repeat
            3 { 255 exch sub 3 1 roll } repeat
            3 copy 1 index eq 3 1 roll eq and
            { pop pop 0 0 0 4 -1 roll } { 0 } ifelse
            4 { 255 exch sub 4 1 roll } repeat
            imgsep put
          } repeat
        } bdf
/imgmskeat { /ll 1 def in 6 2 roll 4 { pop } repeat mul 8 div cvi
             { rd_buf ibf length sub dup 0 le { pop exit } if } loop
           } bdf
/gryimgeat { /ll 1 def in 6 2 roll 4 { pop } repeat mul cvi
             { rd_buf ibf length sub dup 0 le { pop exit } if } loop
           } bdf
/mnoimgeat { /ll 1 def in 6 2 roll 4 { pop } repeat
             exch 7 add 8 div cvi mul cvi
             { rd_buf ibf length sub dup 0 le { pop exit } if } loop
           } bdf
/clrimgeat { /ll 3 def in 6 2 roll 4 { pop } repeat mul ll mul cvi
             { rd_buf ibf length sub dup 0 le { pop exit } if } loop
           } bdf
/passset1 {
            /k { ucrem popit ksepr } def
            /K { ucrem popit Ksepr } def
            /x { txim dup -1 eq
                   { 7 { pop } repeat /sc { 1 setgray } def
                   /F { sc eofill } def /im { sc _im } def _opon notxim }
                   { 6 { pop } repeat /F { newpath } def
                     /im { eatim } def _opof notxim }
                   ifelse
               } def
            /X { dup -1 eq
                   { 7 { pop } repeat /S { 1 setgray .strok } def
                     /IM { 1 setgray _im } def }
                   { 6 { pop } repeat /S { newpath } def
                     /IM { eatim } def }
                   ifelse
               } def
            /gryimg { gryimgeat } def
            /mnoimg { mnoimgeat } def
            /clrimg { /imgsep { popit } def /ll 3 def in
                      imgtrn 8 imgmtx { rd_buf cl2sep ibf } image } bdf
            /clrimg_a { as_set clrimg } def
            /clrimg_b { bn_set clrimg } def
          } bdf
/ucrem {
         dup 0 eq {
            4 copy pop 1 index dup 0 lt not 5 1 roll eq 3 1 roll eq and and
            { pop pop pop 0 0 0 4 -1 roll } if
         } if
       } bdf

%
%  Separation functions
%

/CynPass  { /popit { pop pop pop } def passset1 } bdf
/MagPass  { /popit { pop pop exch pop } def passset1 } bdf
/YelPass  { /popit { pop exch pop exch pop } def passset1 } bdf
/BlkPass  {
            /k { ucrem 3 { exch pop } repeat ksepr } def
            /K { ucrem 3 { exch pop } repeat Ksepr } def
            /x { txim dup -1 eq
                   { 7 { pop } repeat /sc { 1 setgray } def
                   /F { sc eofill } def /im { sc _im } def _opon notxim }
                   { 6 { pop } repeat /F { newpath } def
                     /im { eatim } def _opof notxim }
                   ifelse
               } def
            /X { dup -1 eq
                   { 7 { pop } repeat /S { 1 setgray .strok } def
                     /IM { 1 setgray _im } def }
                   { 6 { pop } repeat /S { newpath } def
                     /IM { eatim } def }
                   ifelse
               } def
            /clrimg { /imgsep { 3 { exch pop } repeat } def /ll 3 def in
                      imgtrn 8 imgmtx { rd_buf cl2sep ibf } image } bdf
            /clrimg_a { as_set clrimg } def
            /clrimg_b { bn_set clrimg } def
          } bdf
/CustPass {
            /_CC exch def
            /k { 4 { pop } repeat /sc { 1 setgray } def
                 /F { sc eofill } def /im { sc _im } def _opon } def
            /K { 4 { pop } repeat /S { 1 setgray .strok } def
                 /IM { 1 setgray _im } def } def
            /x { txim dup -1 eq
                   { pop exch _CC eq
                       { 1 exch sub /_b exch def /sc { _b setgray } def
                         /F { sc eofill } def /im { sc _im } def _opon
                         4 { pop } repeat }
                       { 5 { pop } repeat /sc { 1 setgray } def
                         /F { sc eofill } def /im { sc _im } def _opon }
                       ifelse
                   }
                   { exch _CC eq
                       { 1 exch sub /_b exch def /sc { _b setgray } def
                         /F { sc eofill } def /im { sc _im } def _opon
                         4 { pop } repeat }
                       { /F { newpath } def /im { eatim } def _opof
                         notxim 5 { pop } repeat }
                       ifelse
                   }
                   ifelse
               } def
            /X { dup -1 eq
                   { pop exch _CC eq
                       { 1 exch sub /_B exch def /S { _B setgray .strok } def
                         /IM { _B setgray _im } def 4 { pop } repeat }
                       { 5 { pop } repeat /S { 1 setgray .strok } def
                         /IM { 1 setgray _im } def }
                       ifelse
                   }
                   { exch _CC eq
                       { 1 exch sub /_B exch def /S { _B setgray .strok } def
                         /IM { _B setgray _im } def 4 { pop } repeat }
                       { /S { newpath } def /IM { eatim } def
                         5 { pop } repeat }
                       ifelse
                   }
                   ifelse
               } def
            /g { dup -1 eq
                   { pop _CC eq
                       { /_b exch def /sc { _b setgray } def
                         /F { sc eofill } def /im { sc _im } def _opon }
                       { pop /sc { 1 setgray } def
                         /F { sc eofill } def /im { sc _im } def _opon }
                       ifelse
                   }
                   { _CC eq
                       { /_b exch def /sc { _b setgray } def
                         /F { sc eofill } def /im { sc _im } def _opon }
                       { pop /F { newpath } def /im { eatim } def _opof }
                       ifelse
                   }
                   ifelse
               } def
            /G { dup -1 eq
                   { pop _CC eq
                        { /_B exch def /SC { _B setgray } def
                          /S { SC .strok } def /IM { SC _im } def }
                        { pop /SC { 1 setgray } def
                          /S { SC .strok } def /IM { SC _im } def }
                        ifelse
                   }
                   { _CC eq
                        { /_B exch def /SC { _B setgray } def
                          /S { SC .strok } def /IM { SC _im } def }
                        { pop /S { newpath } def /IM { eatim } def }
                        ifelse
                   }
                   ifelse
               } def
            /gryimg { gryimgeat } def
            /mnoimg { mnoimgeat } def
            /clrimg { clrimgeat } def
            /clrimg_a { as_set clrimg } def
            /clrimg_b { bn_set clrimg } def
          } bdf

%%EndProcSet
%%EndProlog
%%BeginSetup
/PSSAVE save def
newpath
%%EndSetup
512 dict begin
gsave
0 j
0 J
3.85 M
0.72 w
0.000 0.000 0.000 0.000 K
0.24 w
0 J
0 j
0.000 0.000 0.000 1.000 K
grestore gsave
113.28 5.76 m
396.72 5.76 l
396.72 277.44 l
113.28 277.44 l
113.28 5.76 l
clip newpath
249.36 104.88 m
291.60 105.60 l
291.60 128.16 l
248.88 130.08 l
249.36 104.88 l
S
198.96 104.40 m
222.96 105.36 l
224.40 146.64 l
200.16 146.16 l
198.96 104.40 l
S
u
grestore gsave
0.00 0.00 m
566.88 0.00 l
566.88 793.68 l
0.00 793.68 l
0.00 0.00 l
clip newpath
202.32 28.32 m
222.72 28.32 l
S
U
u
202.32 32.40 m
202.32 24.00 l
S
U
u
0.000 0.000 0.000 1.000 k
/Times-Roman 7.966079 0 0 0 z
[ 1 0 0 1 192.72 24.24 ] e 1 (0) t T
U
u
222.72 28.32 m
222.72 24.00 l
S
U
u
save /krnary [ 3.839999 3.839999 1.92  ] def
[ 1 0 0 1 228.24 18.95999 ] e 4 (10 m) t T
restore
U
u
save /krnary [ 5.28 3.839999 2.16 2.16 3.359999 6 2.16 1.92 2.16 2.4 3.359999
 3.839999 3.359999 3.839999 3.359999  ] def
[ 1 0 0 1 212.4 7.2 ] e 16 (Cottam: trenches) t T
restore
U
showpage
end
PSSAVE restore
%%PageTrailer
%%Trailer
%%EOF
